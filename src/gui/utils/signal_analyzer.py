"""
Signal Analyzer utility for analyzing strategy signals.

Provides analysis and statistics about entry/exit signals generated by strategies.
"""

import pandas as pd
from typing import Dict, Any, Tuple


class SignalAnalyzer:
    """
    Analyzer for strategy entry/exit signals.

    Provides methods to:
    - Count and analyze signals
    - Calculate signal statistics
    - Identify signal patterns
    """

    @staticmethod
    def analyze_signals(
        entries: pd.Series,
        exits: pd.Series,
        prices: pd.Series
    ) -> Dict[str, Any]:
        """
        Analyze entry and exit signals.

        Args:
            entries: Boolean series of entry signals
            exits: Boolean series of exit signals
            prices: Price series for signal price calculation

        Returns:
            Dictionary with signal analysis
        """
        if entries is None or exits is None:
            return {
                'total_entries': 0,
                'total_exits': 0,
                'signal_ratio': 0.0,
                'avg_entry_price': 0.0,
                'avg_exit_price': 0.0
            }

        analysis = {
            'total_entries': int(entries.sum()) if isinstance(entries, pd.Series) else 0,
            'total_exits': int(exits.sum()) if isinstance(exits, pd.Series) else 0,
        }

        # Calculate signal ratio (entries vs total bars)
        if len(entries) > 0:
            analysis['signal_ratio'] = (analysis['total_entries'] / len(entries)) * 100
        else:
            analysis['signal_ratio'] = 0.0

        # Average signal prices if prices provided
        if prices is not None and len(prices) > 0:
            if analysis['total_entries'] > 0:
                entry_prices = prices[entries]
                analysis['avg_entry_price'] = float(entry_prices.mean())
            else:
                analysis['avg_entry_price'] = 0.0

            if analysis['total_exits'] > 0:
                exit_prices = prices[exits]
                analysis['avg_exit_price'] = float(exit_prices.mean())
            else:
                analysis['avg_exit_price'] = 0.0

        return analysis

    @staticmethod
    def calculate_signal_frequency(signals: pd.Series, timeframe: str = 'daily') -> Dict[str, float]:
        """
        Calculate signal frequency statistics.

        Args:
            signals: Boolean series of signals
            timeframe: 'daily', 'weekly', 'monthly'

        Returns:
            Dictionary with frequency statistics
        """
        if signals is None or signals.empty:
            return {
                'signals_per_period': 0.0,
                'days_between_signals': 0.0
            }

        total_signals = int(signals.sum())
        total_periods = len(signals)

        if total_periods == 0:
            return {
                'signals_per_period': 0.0,
                'days_between_signals': 0.0
            }

        signals_per_period = total_signals / total_periods

        # Days between signals
        if total_signals > 1:
            days_between = total_periods / total_signals
        else:
            days_between = total_periods

        return {
            'signals_per_period': float(signals_per_period),
            'days_between_signals': float(days_between)
        }

    @staticmethod
    def get_signal_summary(
        entries: pd.Series,
        exits: pd.Series,
        prices: pd.Series
    ) -> str:
        """
        Get human-readable summary of signals.

        Args:
            entries: Entry signals
            exits: Exit signals
            prices: Price data

        Returns:
            Formatted summary string
        """
        analysis = SignalAnalyzer.analyze_signals(entries, exits, prices)

        summary_parts = [
            f"Entry Signals: {analysis['total_entries']}",
            f"Exit Signals: {analysis['total_exits']}",
            f"Signal Frequency: {analysis['signal_ratio']:.2f}% of bars",
        ]

        if 'avg_entry_price' in analysis and analysis['avg_entry_price'] > 0:
            summary_parts.append(f"Avg Entry Price: ${analysis['avg_entry_price']:.2f}")

        if 'avg_exit_price' in analysis and analysis['avg_exit_price'] > 0:
            summary_parts.append(f"Avg Exit Price: ${analysis['avg_exit_price']:.2f}")

        return "\n".join(summary_parts)

    @staticmethod
    def detect_signal_issues(entries: pd.Series, exits: pd.Series) -> list:
        """
        Detect potential issues with signals.

        Args:
            entries: Entry signals
            exits: Exit signals

        Returns:
            List of issue descriptions
        """
        issues = []

        if entries is None or exits is None:
            issues.append("No signals generated")
            return issues

        total_entries = int(entries.sum())
        total_exits = int(exits.sum())

        # No signals at all
        if total_entries == 0 and total_exits == 0:
            issues.append("Strategy generated no entry or exit signals")

        # Only entries, no exits
        elif total_entries > 0 and total_exits == 0:
            issues.append("Strategy has entries but no exits - positions may not close")

        # Only exits, no entries
        elif total_entries == 0 and total_exits > 0:
            issues.append("Strategy has exits but no entries - unusual pattern")

        # Imbalanced signals
        elif abs(total_entries - total_exits) > max(total_entries, total_exits) * 0.5:
            issues.append(f"Signal imbalance: {total_entries} entries vs {total_exits} exits")

        # Very frequent signals (> 50% of bars)
        signal_ratio = (total_entries / len(entries)) * 100 if len(entries) > 0 else 0
        if signal_ratio > 50:
            issues.append(f"Very frequent signals ({signal_ratio:.1f}% of bars) - may overfit")

        # Very rare signals (< 1% of bars)
        elif signal_ratio < 1 and signal_ratio > 0:
            issues.append(f"Very rare signals ({signal_ratio:.1f}% of bars) - may undertrade")

        if not issues:
            issues.append("No signal issues detected")

        return issues
